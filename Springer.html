<!--
    Springer LaTeX Metadata Extractor
    Author: Jan Kohout
    Email: jan.kohout@vscht.cz
    Version: 1.0
    Date: 2025-02-14

    Description:
    Paste your Springer LaTeX (.tex) content into the input box.
    Click "Extract" to parse title, abstract, authors, and affiliations.
    Any value shown inside a blue box is clickable and copies to clipboard.
-->

<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Springer LaTeX Extractor</title>

    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 40px;
            background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
        }

        h1 {
            color: #333;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 32px;
            font-weight: 600;
        }

        textarea {
            width: 100%;
            height: 120px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #56ab2f;
        }

        h2 {
            margin-top: 32px;
            margin-bottom: 16px;
            color: #444;
            font-size: 24px;
            font-weight: 600;
            border-bottom: 3px solid #56ab2f;
            padding-bottom: 8px;
        }

        .row {
            margin: 12px 0;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #56ab2f;
            line-height: 32px;
        }

        .row strong {
            font-weight: 600;
            color: #333;
            font-size: 18px;
        }

        .copybox {
            padding: 4px 10px;
            margin: 2px 4px;
            background: #e8f0ff;
            border: 1px solid #8fb2ff;
            border-radius: 6px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            min-height: 28px;
            transition: all 0.2s;
            vertical-align: middle;
        }

        .copybox:hover {
            background: #d9e7ff;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(86, 171, 47, 0.3);
        }

        .copybox.truncate {
            max-width: 400px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .abstract-box {
            display: inline-block;
            max-width: 100%;
            white-space: normal;
            word-wrap: break-word;
            line-height: 1.6;
        }

        .smallhint {
            font-size: 14px;
            color: #666;
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .label {
            display: inline-block;
            min-height: 28px;
            line-height: 28px;
            vertical-align: middle;
            font-weight: 600;
        }

        .tooltip {
            position: fixed;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            max-width: 400px;
            word-wrap: break-word;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            line-height: 1.4;
        }

        .author-info {
            font-size: 12px;
            color: #666;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        .author-info strong {
            color: #333;
        }

        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            font-size: 13px;
            color: #666;
        }

        .footer a {
            color: #56ab2f;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        .corresponding {
            background: #e8f5e9 !important;
            border-left: 4px solid #2e7d32 !important;
        }

        .affil-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 8px 16px;
            align-items: start;
        }

        .affil-grid > * {
            min-height: 28px;
            display: flex;
            align-items: center;
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>Springer LaTeX Metadata Extractor</h1>

        <div class="author-info">
            <strong>Author:</strong> Jan Kohout | 
            <strong>Web:</strong> <a href="https://jankoweb.github.io" target="_blank" style="color: #56ab2f; text-decoration: none;">jankoweb.github.io</a> | 
            <strong>Last updated:</strong> December 11, 2025
        </div>

        <div class="smallhint">
            <strong>Purpose:</strong> Developed for easier manuscript submission to Springer journals.<br>
            Helps you fill in metadata at <a href="https://submission.springernature.com/" target="_blank" style="color: #56ab2f;">submission.springernature.com</a><br><br>
            <strong>How it helps:</strong> Instead of manually searching through your LaTeX file and copying text,<br>
            simply click any blue box to copy the content (title, abstract, author names, emails, etc.) and paste directly into the submission form.<br><br>
            Paste your LaTeX manuscript text below. Extraction happens automatically.<br>
            Click any blue box to copy its content to clipboard.
        </div>

        <textarea id="texinput" placeholder="Paste your Springer .tex file content here (including \title, \abstract, \author, \affil commands)...">Paste your Springer .tex file content here (including \title, \abstract, \author, \affil commands)...</textarea>
        <br><br>

        <div id="out"></div>
    </div>

    <script>
        /* ------------------------------
           Decode Czech LaTeX accents
        -------------------------------- */
        function decodeLatexAccents(str) {
            if (!str) return "";

            const map = {
                "\\v{s}": "š", "\\v{S}": "Š",
                "\\v{c}": "č", "\\v{C}": "Č",
                "\\v{z}": "ž", "\\v{Z}": "Ž",
                "\\v{e}": "ě", "\\v{E}": "Ě",
                "\\v{n}": "ň", "\\v{N}": "Ň",
                "\\v{r}": "ř", "\\v{R}": "Ř",
                "\\v{t}": "ť", "\\v{T}": "Ť",

                "\\'{a}": "á", "\\'{A}": "Á",
                "\\'{e}": "é", "\\'{E}": "É",
                "\\'{i}": "í", "\\'{I}": "Í",
                "\\'{o}": "ó", "\\'{O}": "Ó",
                "\\'{u}": "ú", "\\'{U}": "Ú",
                "\\'{y}": "ý", "\\'{Y}": "Ý",

                "\\r{u}": "ů", "\\r{U}": "Ů"
            };

            for (const key in map) {
                str = str.replaceAll(key, map[key]);
            }

            return str;
        }

        /* ------------------------------
           Extract text inside balanced { }
        -------------------------------- */
        function extractBalanced(str, startIndex) {
            let i = startIndex, depth = 1;
            while (i < str.length && depth > 0) {
                if (str[i] === "{") depth++;
                if (str[i] === "}") depth--;
                i++;
            }
            return str.slice(startIndex, i - 1);
        }

        /* ------------------------------
           Extract fnm{...}, sur{...}
        -------------------------------- */
        function extractFirstName(block) {
            const pos = block.indexOf("\\fnm{");
            if (pos === -1) return "";
            const start = block.indexOf("{", pos) + 1;
            return decodeLatexAccents(extractBalanced(block, start));
        }

        function extractSurname(block) {
            const pos = block.indexOf("\\sur{");
            if (pos === -1) return "";
            const start = block.indexOf("{", pos) + 1;
            return decodeLatexAccents(extractBalanced(block, start));
        }

        /* ------------------------------
           Extract authors
        -------------------------------- */
        function parseAuthors(tex) {
            const authors = [];
            let pos = 0;

            while (true) {
                // Find next \author command
                const authorStart = tex.indexOf("\\author", pos);
                if (authorStart === -1) break;

                // Check if it's \author*
                const isStar = tex[authorStart + 7] === "*";
                const afterAuthor = authorStart + (isStar ? 8 : 7);

                // Extract affiliation numbers [1,2,3]
                const affilMatch = tex.slice(afterAuthor).match(/^\[([^\]]+)\]/);
                if (!affilMatch) {
                    pos = afterAuthor;
                    continue;
                }
                const affils = affilMatch[1].split(",").map(x => x.trim());

                // Find the opening brace after affiliation
                const bracePos = afterAuthor + affilMatch[0].length;
                if (tex[bracePos] !== "{") {
                    pos = bracePos;
                    continue;
                }

                // Extract the balanced author block
                const block = extractBalanced(tex, bracePos + 1);

                // Find the next \email command
                const searchStart = bracePos + block.length + 1;
                const emailMatch = tex.slice(searchStart).match(/\\email\{([^}]*)\}/);
                if (!emailMatch) {
                    pos = searchStart;
                    continue;
                }
                const email = emailMatch[1];

                const fn = extractFirstName(block);
                const sn = extractSurname(block);
                
                // Check if this is corresponding author
                const fullMatch = tex.slice(authorStart, searchStart + emailMatch.index + emailMatch[0].length);
                const isCorresponding = block.includes("\\corref") || isStar;

                authors.push({
                    firstName: fn,
                    lastName: sn,
                    email,
                    affils,
                    isCorresponding
                });

                pos = searchStart + emailMatch.index + emailMatch[0].length;
            }
            return authors;
        }

        /* ------------------------------
           Extract affiliations (balanced)
        -------------------------------- */
        function extractAffils(tex) {
            const out = [];
            let pos = 0;

            while (true) {
                const start = tex.indexOf("\\affil", pos);
                if (start === -1) break;

                const idx = tex.slice(start).match(/\\affil\*?\[([0-9]+)\]/);
                if (!idx) break;

                const index = idx[1];
                const braceStart = tex.indexOf("{", start) + 1;
                const block = extractBalanced(tex, braceStart);

                out.push({ index, block });
                pos = braceStart + block.length;
            }

            return out;
        }

        /* ------------------------------
           Parse affiliation fields
        -------------------------------- */
        function parseAffiliationBlock(block) {
            function get(cmd) {
                const m = block.match(new RegExp("\\\\" + cmd + "\\{([^}]*)\\}"));
                return m ? decodeLatexAccents(m[1].trim()) : "";
            }
            return {
                dep: get("orgdiv"),
                org: get("orgname"),
                street: get("street"),
                city: get("city"),
                postcode: get("postcode"),
                state: get("state"),
                country: get("country")
            };
        }

        /* ------------------------------
           Main parser
        -------------------------------- */
        function parseSpringer(tex) {
            tex = tex.replace(/%.*/g, "");

            // Extract title using balanced braces
            let title = "";
            const titlePos = tex.indexOf("\\title{");
            if (titlePos !== -1) {
                const titleStart = tex.indexOf("{", titlePos) + 1;
                title = extractBalanced(tex, titleStart);
            }

            // Extract abstract - support both \abstract{} and \begin{abstract}...\end{abstract}
            let abstract = "";
            
            // Try \begin{abstract}...\end{abstract} format first
            const beginAbstractPos = tex.indexOf("\\begin{abstract}");
            if (beginAbstractPos !== -1) {
                const abstractStart = beginAbstractPos + "\\begin{abstract}".length;
                const abstractEnd = tex.indexOf("\\end{abstract}", abstractStart);
                if (abstractEnd !== -1) {
                    abstract = tex.slice(abstractStart, abstractEnd).trim();
                    // Remove leading {} if present
                    if (abstract.startsWith("{}")) {
                        abstract = abstract.substring(2);
                    }
                }
            } else {
                // Try \abstract{} format
                const abstractPos = tex.indexOf("\\abstract{");
                if (abstractPos !== -1) {
                    const abstractStart = tex.indexOf("{", abstractPos) + 1;
                    abstract = extractBalanced(tex, abstractStart);
                }
            }

            const authors = parseAuthors(tex);

            const rawAff = extractAffils(tex);
            const affils = rawAff.map(a => ({
                index: a.index,
                ...parseAffiliationBlock(a.block)
            }));

            return { title, abstract, authors, affils };
        }

        /* ------------------------------
           Generate a clickable copybox
        -------------------------------- */
        function box(value) {
            return `<span class="copybox" data-copy="${value}">${value}</span>`;
        }

        /* ------------------------------
           Generate a truncated copybox
        -------------------------------- */
        function boxTruncate(value, displayText) {
            return `<span class="copybox truncate" data-copy="${value}">${displayText}</span>`;
        }

        /* ------------------------------
           Render output
        -------------------------------- */
        function extract() {
            const tex = document.getElementById("texinput").value;
            const out = document.getElementById("out");
            out.innerHTML = "";

            const data = parseSpringer(tex);

            /* ---- TITLE ---- */
            const t = document.createElement("div");
            t.className = "row";
            t.innerHTML = `<span class="label">Title: </span>${box(data.title)}`;
            out.appendChild(t);

            /* ---- ABSTRACT ---- */
            const abs = document.createElement("div");
            abs.className = "row";
            abs.innerHTML = `<span class="label">Abstract: </span><span class="copybox abstract-box" data-copy="${data.abstract}">${data.abstract}</span>`;
            out.appendChild(abs);

            /* ---- AFFILIATIONS ---- */
            const hA = document.createElement("h2");
            hA.textContent = "Affiliations";
            out.appendChild(hA);

            data.affils.forEach(aff => {
                const row = document.createElement("div");
                row.className = "row";

                let html = `<strong>#${aff.index}</strong><div class="affil-grid" style="display: inline-grid; margin-left: 12px; vertical-align: top;">`;

                // Institution name (organization or department)
                const instName = aff.org || aff.dep;
                if (instName) {
                    html += `<span class="label">Institution name:</span> <span>${box(instName)}</span>`;
                }

                // Institution city
                if (aff.city) html += `<span class="label">Institution city:</span> <span>${box(aff.city)}</span>`;

                // Institution country/territory
                if (aff.country) html += `<span class="label">Institution country/territory:</span> <span>${box(aff.country)}</span>`;

                // Institution details (department if organization exists)
                if (aff.dep && aff.org) {
                    html += `<span class="label">Institution details:</span> <span>${box(aff.dep)}</span>`;
                }

                html += "</div>";
                row.innerHTML = html;
                out.appendChild(row);
            });


            /* ---- AUTHORS ---- */
            const h = document.createElement("h2");
            h.textContent = "Authors";
            out.appendChild(h);

            data.authors.forEach((a, i) => {
                const affTexts = a.affils.map(idx => {
                    const af = data.affils.find(x => x.index === idx);
                    if (!af) return "";
                    return af.org || "";
                });

                const row = document.createElement("div");
                row.className = a.isCorresponding ? "row corresponding" : "row";
                
                let html = `<strong>#${i + 1}</strong><div class="affil-grid" style="display: inline-grid; margin-left: 12px; vertical-align: top;">`;
                
                html += `<span class="label">Given names:</span> <span>${box(a.firstName)}</span>`;
                html += `<span class="label">Family name:</span> <span>${box(a.lastName)}</span>`;
                html += `<span class="label">Email:</span> <span>${box(a.email)}</span>`;
                
                if (affTexts.length > 0 && affTexts.some(x => x)) {
                    html += `<span class="label">Primary affiliation:</span> <span>${affTexts.map(x => box(x)).join(" ")}</span>`;
                }
                
                if (a.isCorresponding) {
                    html += `<span></span> <span><strong style='color: #2e7d32;'>(Corresponding Author)</strong></span>`;
                }
                
                html += "</div>";
                row.innerHTML = html;
                out.appendChild(row);
            });
        }

        /* ------------------------------
           Global click handler for copyboxes
        -------------------------------- */
        let tooltip = null;

        document.addEventListener("click", e => {
            if (e.target.classList.contains("copybox")) {
                const txt = e.target.dataset.copy;
                navigator.clipboard.writeText(txt);
                e.target.style.background = "#c9f7c9";
                setTimeout(() => e.target.style.background = "#e8f0ff", 200);
            }
        });

        // Show tooltip on hover
        document.addEventListener("mouseover", e => {
            if (e.target.classList.contains("copybox")) {
                const txt = e.target.dataset.copy;
                
                // Create tooltip
                tooltip = document.createElement("div");
                tooltip.className = "tooltip";
                tooltip.textContent = txt;
                document.body.appendChild(tooltip);
                
                // Position tooltip
                const rect = e.target.getBoundingClientRect();
                tooltip.style.left = rect.left + "px";
                tooltip.style.top = (rect.bottom + 5) + "px";
                
                // Adjust if tooltip goes off screen
                const tooltipRect = tooltip.getBoundingClientRect();
                if (tooltipRect.right > window.innerWidth) {
                    tooltip.style.left = (window.innerWidth - tooltipRect.width - 10) + "px";
                }
                if (tooltipRect.bottom > window.innerHeight) {
                    tooltip.style.top = (rect.top - tooltipRect.height - 5) + "px";
                }
            }
        });

        // Hide tooltip on mouseout
        document.addEventListener("mouseout", e => {
            if (e.target.classList.contains("copybox") && tooltip) {
                tooltip.remove();
                tooltip = null;
            }
        });

        /* ------------------------------
           Auto-extract on textarea input
        -------------------------------- */
        const textarea = document.getElementById("texinput");
        
        // Clear placeholder text on focus
        textarea.addEventListener("focus", function() {
            if (this.value === this.getAttribute("placeholder")) {
                this.value = "";
            }
        });
        
        // Restore placeholder if empty on blur
        textarea.addEventListener("blur", function() {
            if (this.value === "") {
                this.value = this.getAttribute("placeholder");
            }
        });
        
        textarea.addEventListener("input", extract);

        /* ------------------------------
           Prevent accidental page reload
        -------------------------------- */
        window.addEventListener("beforeunload", function(e) {
            const textarea = document.getElementById("texinput");
            const placeholder = textarea.getAttribute("placeholder");
            
            // Only prompt if there's actual content (not just placeholder)
            // This will trigger browser's default warning dialog
            if (textarea.value && textarea.value !== placeholder && textarea.value.trim() !== "") {
                // Modern browsers ignore custom message and show their own
                // They typically show: "Changes you made may not be saved" or similar
                e.preventDefault();
                e.returnValue = ""; // Required for Chrome
                return ""; // Required for some browsers
            }
        });
    </script>

</body>

</html>